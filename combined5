import warnings
warnings.filterwarnings("ignore")

import os
import json
import random
import time
from datetime import datetime
from typing import Dict, List

import numpy as np
import pandas as pd
import requests
from nba_api.stats.endpoints import PlayerGameLog
from nba_api.stats.static import players as nba_players

from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
)
from reportlab.lib.styles import getSampleStyleSheet

# =========================================================
# SETTINGS
# =========================================================
NUM_GAMES = 10
SEASONS = ["2025-26", "2024-25"]
SEASON_TYPES = ["Regular Season", "Playoffs"]
MAX_RETRIES = 3

# Hit-rate thresholds (your Script A style)
POINT_THRESHOLDS   = [10, 15, 20, 25, 30]
REB_THRESHOLDS     = [2, 4, 6, 8, 10]
AST_THRESHOLDS     = [2, 4, 6, 8, 10]
STL_THRESHOLDS     = [1, 2]
BLK_THRESHOLDS     = [1, 2]
THREEPM_THRESHOLDS = [1, 2, 3, 4, 5]

STAT_META = {
    "points":   {"label": "Points",   "df_col": "PTS",  "thresholds": POINT_THRESHOLDS},
    "rebounds": {"label": "Rebounds", "df_col": "REB",  "thresholds": REB_THRESHOLDS},
    "assists":  {"label": "Assists",  "df_col": "AST",  "thresholds": AST_THRESHOLDS},
    "steals":   {"label": "Steals",   "df_col": "STL",  "thresholds": STL_THRESHOLDS},
    "blocks":   {"label": "Blocks",   "df_col": "BLK",  "thresholds": BLK_THRESHOLDS},
    "threes":   {"label": "3PM",      "df_col": "FG3M", "thresholds": THREEPM_THRESHOLDS},
}
STATS = list(STAT_META.keys())

# SGO odds API
SGO_API_KEY = os.getenv("SGO_API_KEY", "7243468c02f981445249730c03b426c1")
BASE_URL = "https://api.sportsgameodds.com/v2/events"

# Caches
ODDS_CACHE_DIR = "odds_cache"
PLAYER_CACHE_DIR = "cache"
os.makedirs(ODDS_CACHE_DIR, exist_ok=True)
os.makedirs(PLAYER_CACHE_DIR, exist_ok=True)

# Injury statuses to exclude
EXCLUDE_STATUSES = {"OUT", "DOUBTFUL", "INACTIVE", "SUSPENDED", "QUESTIONABLE", "DTD"}

# =========================================================
# PLAYER LOG CACHE
# =========================================================
def _safe_filename(name: str) -> str:
    return name.replace(" ", "_").replace(".", "").replace("'", "")

def load_cache_player(player_name: str) -> List[dict]:
    fp = os.path.join(PLAYER_CACHE_DIR, f"{_safe_filename(player_name)}.json")
    if os.path.exists(fp):
        try:
            with open(fp, "r") as f:
                data = json.load(f)
            df = pd.DataFrame(data)
            if not df.empty and "GAME_DATE" in df.columns:
                df["GAME_DATE"] = pd.to_datetime(df["GAME_DATE"], errors="coerce")
            return df.to_dict(orient="records")
        except Exception as e:
            print(f"  ‚ö†Ô∏è Error loading cache for {player_name}: {e}")
    return []

def save_cache_player(player_name: str, data: List[dict]) -> None:
    fp = os.path.join(PLAYER_CACHE_DIR, f"{_safe_filename(player_name)}.json")
    with open(fp, "w") as f:
        json.dump(data, f, indent=2, default=str)

def safe_fetch_player_logs(player_id: int, season: str, stype: str) -> pd.DataFrame:
    for attempt in range(MAX_RETRIES):
        try:
            time.sleep(random.uniform(0.3, 0.8))
            return PlayerGameLog(
                player_id=player_id,
                season=season,
                season_type_all_star=stype
            ).get_data_frames()[0]
        except Exception as e:
            print(f"   ‚ö†Ô∏è Attempt {attempt+1} failed for NBA ID {player_id}: {e}")
            time.sleep(1.5 + attempt)
    print(f"   ‚ùå Skipping NBA ID {player_id} after {MAX_RETRIES} failed attempts.")
    return pd.DataFrame()

def get_recent_games_cached(player_name: str, player_id: int) -> pd.DataFrame:
    player_cache = load_cache_player(player_name)
    df_cached = pd.DataFrame(player_cache)
    if not df_cached.empty:
        df_cached["GAME_DATE"] = pd.to_datetime(df_cached["GAME_DATE"], errors="coerce")

    fetched = pd.DataFrame()
    for season in SEASONS:
        for stype in SEASON_TYPES:
            logs = safe_fetch_player_logs(player_id, season, stype)
            if not logs.empty:
                fetched = pd.concat([fetched, logs], ignore_index=True)

    if fetched.empty:
        print(f"  ‚ö†Ô∏è No API data for {player_name}, using cache only.")
        return df_cached.head(NUM_GAMES)

    fetched["GAME_DATE"] = pd.to_datetime(fetched["GAME_DATE"], errors="coerce")
    fetched = fetched[["GAME_DATE","MATCHUP","MIN","PTS","REB","AST","STL","BLK","FG3M"]]
    fetched.sort_values("GAME_DATE", ascending=False, inplace=True)
    fetched = fetched.head(NUM_GAMES)

    if df_cached.empty:
        combined = fetched
    else:
        combined = pd.concat([fetched, df_cached], ignore_index=True)
        combined["GAME_DATE"] = pd.to_datetime(combined["GAME_DATE"], errors="coerce")
        combined = (combined
                    .drop_duplicates(subset="GAME_DATE")
                    .sort_values("GAME_DATE", ascending=False)
                    .head(NUM_GAMES))

    print(f"  ‚ôªÔ∏è Updating cache for {player_name} with {len(fetched)} fetched rows.")
    save_cache_player(player_name, combined.to_dict(orient="records"))
    return combined

# =========================================================
# CONFIDENCE / EDGE HELPERS
# =========================================================
def hit_rate(series, threshold):
    s = pd.to_numeric(series, errors="coerce").dropna()
    total = len(s)
    if total == 0:
        return 0.0, 0, 0
    hits = (s >= threshold).sum()
    return hits / total * 100, int(hits), int(total)

def compute_confidence(df: pd.DataFrame, stat_col: str, threshold: int) -> float:
    if df.empty or stat_col not in df.columns:
        return 0.0
    values = pd.to_numeric(df[stat_col], errors="coerce").dropna().tolist()
    if not values:
        return 0.0

    mins = pd.to_numeric(df["MIN"], errors="coerce").fillna(0).tolist() if "MIN" in df.columns else [0]*len(values)

    base_hits = sum(v >= threshold for v in values)
    total = len(values)
    base_pct = base_hits / total * 100

    positive_mins = [m for m in mins if m > 0]
    median_min = np.median(positive_mins) if positive_mins else None

    penalties = 0.0
    ignorable = 0
    for v, m in zip(values, mins):
        if v >= threshold:
            continue
        gap = threshold - v
        low_min = bool(median_min and m < 0.5 * median_min)
        close_miss = gap <= 2
        if low_min or close_miss:
            ignorable += 1
            continue
        penalties += min(gap * 1.5, 10)

    outlier_bonus = 5 if (base_hits >= 1 and penalties == 0 and ignorable > 0) else 0
    stat_std = float(np.std(values))
    consistency_bonus = 5 if stat_std <= 2 else (2 if stat_std <= 4 else 0)

    conf = base_pct + outlier_bonus + consistency_bonus - penalties
    return float(max(0, min(100, round(conf, 1))))

def american_to_implied_prob(odds: int) -> float:
    try:
        o = int(odds)
    except Exception:
        return 0.0
    if o < 0:
        return (-o) / ((-o) + 100)
    return 100 / (o + 100)

# =========================================================
# ODDS CACHE HELPERS
# =========================================================
def get_odds_cache_path(tag: str) -> str:
    today = datetime.utcnow().strftime("%Y%m%d")
    return os.path.join(ODDS_CACHE_DIR, f"{tag}_{today}.json")

def load_cached_odds(tag: str):
    p = get_odds_cache_path(tag)
    if os.path.exists(p):
        try:
            with open(p, "r") as f:
                return json.load(f)
        except Exception:
            return None
    return None

def save_cached_odds(data, tag: str):
    with open(get_odds_cache_path(tag), "w") as f:
        json.dump(data, f, indent=2)

# =========================================================
# SGO: GAMES + PROPS
# =========================================================
def get_all_games_today_sgo():
    params = {
        "apiKey": SGO_API_KEY,
        "leagueID": "NBA",
        "oddsAvailable": "true",
        "bookmakerID": "fanduel",
        "limit": "200",
    }
    r = requests.get(BASE_URL, params=params, timeout=20)
    r.raise_for_status()
    return r.json().get("data", [])

def get_starters(players_dict: Dict[str, dict]):
    # Simple fallback heuristic: first 5 by playerID sort
    return sorted(players_dict.keys())[:5]

def build_odds_request(player_ids: List[str]) -> str:
    odd_ids = []
    for pid in player_ids:
        for stat in STATS:
            odd_ids.append(f"{stat}-{pid}-game-ou-over")
    return ",".join(odd_ids)

def fetch_team_props(odd_id_string: str, tag: str):
    cached = load_cached_odds(tag)
    if cached:
        return cached
    params = {
        "apiKey": SGO_API_KEY,
        "leagueID": "NBA",
        "bookmakerID": "fanduel",
        "oddsAvailable": "true",
        "oddIDs": odd_id_string,
        "includeOpposingOdds": "true",
        "includeAltLines": "true",   # we‚Äôll filter to main below
        "limit": "1",
    }
    for _ in range(3):
        r = requests.get(BASE_URL, params=params, timeout=20)
        js = r.json()
        if js.get("data"):
            save_cached_odds(js, tag)
            return js
        time.sleep(1)
    return None

def parse_props(player_id: str, stat: str, odds_obj: dict):
    """
    Return only the MAIN FanDuel line for this (player, stat).
    """
    odd_id = f"{stat}-{player_id}-game-ou-over"
    if odd_id not in odds_obj:
        return None
    node = odds_obj[odd_id]
    bm = node.get("byBookmaker", {})
    if "fanduel" not in bm:
        return None
    book = bm["fanduel"]
    # MAIN line only
    try:
        return [{
            "overUnder": float(node["bookOverUnder"]),
            "odds": int(book["odds"]),
            "is_main": True,
        }]
    except Exception:
        return None

# =========================================================
# LINE ‚Üí THRESHOLD
# =========================================================
def round_half_up(x: float) -> int:
    return int(np.floor(x + 0.5))

def find_best_threshold(thresholds: List[int], line_value: float):
    if not thresholds:
        return None
    target = round_half_up(line_value)
    best = None
    best_dist = None
    for t in thresholds:
        d = abs(t - target)
        if best is None or d < best_dist or (d == best_dist and t > best):
            best = t
            best_dist = d
    return best

# =========================================================
# INJURIES FROM SGO (native, reliable)
# =========================================================
def extract_injuries_from_sgo(games: List[dict]) -> Dict[str, str]:
    """
    Build a {playerName: STATUS} map directly from SGO game payload.
    """
    injuries: Dict[str, str] = {}
    for g in games:
        players = g.get("players") or {}
        for _, info in players.items():
            name = info.get("name")
            status = (info.get("status") or "").strip().upper()
            if name and status:
                injuries[name] = status
    return injuries

def fetch_nba_injury_report():
    """
    Pulls NBA injury data from the Sleeper public API.
    Returns { 'Full Name': 'STATUS' } mapping.
    """
    url = "https://api.sleeper.app/v1/players/nba"

    try:
        r = requests.get(url, timeout=10)
        r.raise_for_status()
        data = r.json()

        injury_lookup = {}

        for player_id, item in data.items():
            status = item.get("injury_status")
            if status:
                full_name = f"{item.get('first_name', '')} {item.get('last_name', '')}".strip()
                if full_name:
                    injury_lookup[full_name] = status.upper().strip()

        print(f"üîç Sleeper injuries loaded: {len(injury_lookup)} players")
        return injury_lookup

    except Exception as e:
        print("‚ö†Ô∏è Sleeper injury fetch failed:", e)
        return {}


# =========================================================
# CORE PROCESS
# =========================================================
def process_all_games():
    # Pull all games once (used for both injuries + odds)
    games = get_all_games_today_sgo()
    if not games:
        print("‚ö†Ô∏è No games returned from SGO.")
        return []

    # Injury report from SGO itself
    injury_report = fetch_nba_injury_report()
    print("\nüîç Injury Report sample (from SGO):")
    for i, (n, s) in enumerate(list(injury_report.items())[:20]):
        print(f"  {n}: {s}")
    if len(injury_report) > 20:
        print(f"  ... (+{len(injury_report)-20} more)")

    all_game_results = []

    for game in games:
        if "players" not in game:
            print("  ‚ö†Ô∏è Game has no player data ‚Äî skipping.")
            continue

        home = game["teams"]["home"]
        away = game["teams"]["away"]
        players_dict = game["players"]

        home_name = home["names"]["medium"]
        away_name = away["names"]["medium"]
        game_label = f"{away_name} @ {home_name}"

        print("\n==============================")
        print(game_label)
        print("==============================")

        home_players = {pid: p for pid, p in players_dict.items() if p["teamID"] == home["teamID"]}
        away_players = {pid: p for pid, p in players_dict.items() if p["teamID"] == away["teamID"]}

        home_starters = get_starters(home_players)
        away_starters = get_starters(away_players)

        home_req = build_odds_request(home_starters)
        away_req = build_odds_request(away_starters)

        home_data = fetch_team_props(home_req, tag=home_name)
        away_data = fetch_team_props(away_req, tag=away_name)

        if not home_data or not home_data.get("data"):
            print("  ‚ö†Ô∏è Home team props unavailable ‚Äî skipping game.")
            continue
        if not away_data or not away_data.get("data"):
            print("  ‚ö†Ô∏è Away team props unavailable ‚Äî skipping game.")
            continue

        home_odds_obj = home_data["data"][0]["odds"]
        away_odds_obj = away_data["data"][0]["odds"]

        game_rows = []

        def process_team(team_players: Dict[str, dict], starter_ids: List[str], odds_obj: dict, tname: str):
            for pid in starter_ids:
                p = team_players.get(pid)
                if not p:
                    continue
                name = p.get("name")
                if not name:
                    continue

                # ---- INJURY FILTER (from SGO) ----
                status = (injury_report.get(name) or "").upper()
                if status in EXCLUDE_STATUSES:
                    print(f"  üö´ Skipping {name} ‚Äî SGO status {status}")
                    continue

                # NBA API match
                found = nba_players.find_players_by_full_name(name)
                if not found:
                    print(f"  ‚ö†Ô∏è Could not match {name} to NBA API ‚Äî skipping.")
                    continue
                nba_id = found[0]["id"]

                # Recent games (cached)
                df = get_recent_games_cached(name, nba_id)
                if df.empty or ("MIN" in df.columns and pd.to_numeric(df["MIN"], errors="coerce").fillna(0).sum() == 0):
                    print(f"  üö´ Skipping {name} ‚Äî no valid recent games.")
                    continue

                for stat_key in STATS:
                    meta = STAT_META[stat_key]
                    df_col = meta["df_col"]
                    thresholds = meta["thresholds"]
                    if df_col not in df.columns:
                        continue

                    props = parse_props(pid, stat_key, odds_obj)
                    if not props:
                        continue

                    # MAIN line only
                    prop = props[0]
                    line_val = prop["overUnder"]
                    odds_val = prop["odds"]
                    thr = find_best_threshold(thresholds, line_val)
                    if thr is None:
                        continue

                    pct, hits, total = hit_rate(df[df_col], thr)
                    conf = compute_confidence(df, df_col, thr)
                    implied = american_to_implied_prob(odds_val) * 100
                    edge = round(conf - implied, 1)

                    game_rows.append({
                        "game": game_label,
                        "team": tname,
                        "player": name,
                        "stat": meta["label"],
                        "line": line_val,
                        "odds": odds_val,
                        "threshold": thr,
                        "hit_rate": round(pct, 1),
                        "hits": hits,
                        "total": total,
                        "confidence": conf,
                        "edge": edge,
                        "is_main": True,
                    })

        process_team(away_players, away_starters, away_odds_obj, away_name)
        process_team(home_players, home_starters, home_odds_obj, home_name)

        if game_rows:
            top_rows = sorted(
                game_rows,
                key=lambda r: (-r["confidence"], -r["edge"], -r["hit_rate"])
            )[:10]

            print("\nTop 10 Props (by Confidence ‚Üí Edge ‚Üí Hit%):")
            for r in top_rows:
                print(
                    f"{r['player']} ({r['team']}) - {r['stat']} "
                    f"line {r['line']} @ {r['odds']} | "
                    f"Hit {r['hits']}/{r['total']} ({r['hit_rate']}%) | "
                    f"Conf {r['confidence']} | Edge {r['edge']}"
                )

            all_game_results.append({"game_label": game_label, "rows": top_rows})
        else:
            print("  ‚ö†Ô∏è No valid props with hit-rate data for this game.")

    return all_game_results

# =========================================================
# PDF REPORT
# =========================================================
def build_pdf_report(all_game_results):
    if not all_game_results:
        print("‚ö†Ô∏è Nothing to write to PDF.")
        return

    today = datetime.now().strftime("%Y-%m-%d")
    pdf_filename = f"NBA_Props_Confidence_{today}.pdf"

    doc = SimpleDocTemplate(pdf_filename, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []

    story.append(Paragraph(f"NBA Props Confidence Report ‚Äì {today}", styles["Title"]))
    story.append(Spacer(1, 12))

    for game in all_game_results:
        story.append(Paragraph(f"<b>{game['game_label']}</b>", styles["Heading2"]))
        story.append(Spacer(1, 6))

        data = [["Player", "Team", "Stat", "Line", "Odds", "Thr", "Hit", "Hit%", "Conf", "Edge"]]
        for r in game["rows"]:
            data.append([
                r["player"],
                r["team"],
                r["stat"],
                f"{r['line']}",
                f"{r['odds']}",
                f"{r['threshold']}+",
                f"{r['hits']}/{r['total']}",
                f"{r['hit_rate']}%",
                f"{r['confidence']}",
                f"{r['edge']}",
            ])

        t = Table(data)
        t.setStyle(TableStyle([
            ("BACKGROUND", (0, 0), (-1, 0), colors.lightgrey),
            ("GRID", (0, 0), (-1, -1), 0.5, colors.grey),
            ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
            ("ALIGN", (3, 1), (-1, -1), "CENTER"),
        ]))

        story.append(t)
        story.append(Spacer(1, 12))

    doc.build(story)
    print(f"\n‚úÖ PDF report saved to {pdf_filename}")

# =========================================================
# MAIN
# =========================================================
def main():
    results = process_all_games()
    build_pdf_report(results)

if __name__ == "__main__":
    main()
