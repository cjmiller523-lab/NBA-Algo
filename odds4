import os
import requests
import time


SGO_API_KEY = os.getenv("SGO_API_KEY", "7243468c02f981445249730c03b426c1")
BASE_URL = "https://api.sportsgameodds.com/v2/events"

import json
import os
from datetime import datetime

CACHE_DIR = "odds_cache"
os.makedirs(CACHE_DIR, exist_ok=True)

def get_cache_path(tag="pacers_suns"):
    today = datetime.utcnow().strftime("%Y%m%d")
    return os.path.join(CACHE_DIR, f"{tag}_{today}.json")


def load_cached_odds(tag="pacers_suns"):
    path = get_cache_path(tag)
    if not os.path.exists(path):
        return None

    with open(path, "r") as f:
        try:
            return json.load(f)
        except json.JSONDecodeError:
            return None


def save_cached_odds(data, tag="pacers_suns"):
    path = get_cache_path(tag)
    with open(path, "w") as f:
        json.dump(data, f, indent=2)



############################################################
# 1. Fetch Pacers vs Suns game
############################################################


def get_game_by_teams(team_a_sub, team_b_sub):
    """
    Find a game where the long team names contain both substrings.
    Example: team_a_sub='pistons', team_b_sub='76ers'
    """
    params = {
        "apiKey": SGO_API_KEY,
        "leagueID": "NBA",
        "oddsAvailable": "true",
        "bookmakerID": "fanduel",
        "limit": "200",
    }

    r = requests.get(BASE_URL, params=params, timeout=15)
    r.raise_for_status()
    js = r.json()

    if "data" not in js or not js["data"]:
        raise RuntimeError("SGO returned no games. Check API key / rate limits.")

    games = js["data"]

    print("\nGames SGO returned with current filters:")
    for g in games:
        home_long = g["teams"]["home"]["names"]["long"]
        away_long = g["teams"]["away"]["names"]["long"]
        print(f"  {away_long} @ {home_long}")

    a = team_a_sub.lower()
    b = team_b_sub.lower()

    for game in games:
        home = game["teams"]["home"]["names"]["long"].lower()
        away = game["teams"]["away"]["names"]["long"].lower()

        if (a in home and b in away) or (a in away and b in home):
            print(
                "\nMatched:",
                game["teams"]["away"]["names"]["long"],
                "@",
                game["teams"]["home"]["names"]["long"],
            )
            return game

    raise ValueError(
        f"No matchup found for '{team_a_sub}' vs '{team_b_sub}' in current SGO response."
    )





############################################################
# 2. Determine starters (top 5 alphabetically)
############################################################


def get_starters(players_dict):
    pids = sorted(players_dict.keys())
    return pids[:5]




############################################################
# 3. Build ALL oddIDs for one team in a single request
############################################################


def build_team_odds_request(player_ids):
    odd_ids = []
    for pid in player_ids:
        odd_ids.append(f"points-{pid}-game-ou-over")
        odd_ids.append(f"rebounds-{pid}-game-ou-over")
        odd_ids.append(f"assists-{pid}-game-ou-over")
    return ",".join(odd_ids)




############################################################
# 4. Fetch ALL props for a team in ONE request
############################################################
def get_team_props_with_cache(odd_id_string, tag):
    cached = load_cached_odds(tag)
    if cached is not None:
        return cached

    data = fetch_team_props(odd_id_string)  # the function we already wrote
    if data:
        save_cached_odds(data, tag)
    return data

def fetch_team_props(odd_id_string):
    params = {
        "apiKey": SGO_API_KEY,
        "leagueID": "NBA",
        "bookmakerID": "fanduel",
        "oddsAvailable": "true",
        "oddIDs": odd_id_string,
        "includeOpposingOdds": "true",
        "includeAltLines": "true",
        "limit": "1",
    }


    # Retry if rate-limited
    for _ in range(3):
        r = requests.get(BASE_URL, params=params, timeout=15)
        js = r.json()


        if "data" in js and js["data"]:
            return js


        time.sleep(1)


    return None




############################################################
# 5. Parse props from the large response
############################################################


def parse_props(player_id, stat, odds_object):
    odd_id = f"{stat}-{player_id}-game-ou-over"


    if odd_id not in odds_object:
        return None


    node = odds_object[odd_id]
    bm = node.get("byBookmaker", {})


    if "fanduel" not in bm:
        return None


    fd = bm["fanduel"]


    main_line = {
        "overUnder": node["bookOverUnder"],
        "odds": fd["odds"],
    }


    alt_lines = fd.get("altLines", [])
    return main_line, alt_lines




############################################################
# 6. Pretty-print props
############################################################


def filter_juiced(lines):
    clean = []
    for x in lines:
        try:
            if int(x["odds"]) >= -600:
                clean.append(x)
        except:
            continue
    return clean




def print_player_props(name, props_dict):
    print(f"\n{name}")
    print("-" * len(name))
    for stat, res in props_dict.items():
        print(f"  {stat.upper()}:")
        if res is None:
            print("    No Data")
            continue


        main_line, alts = res
        alts = filter_juiced(alts)


        print(f"    {main_line['overUnder']} : {main_line['odds']} (main)")


        for a in alts:
            print(f"    {a['overUnder']} : {a['odds']}")




############################################################
# MAIN
############################################################


def main():
    print("\nFetching Pacers vs Suns...\n")


    game = get_game_by_teams("76ers", "pistons")
    players = game["players"]


    home_id = game["teams"]["home"]["teamID"]
    away_id = game["teams"]["away"]["teamID"]


    home_team_short = game["teams"]["home"]["names"]["medium"]
    away_team_short = game["teams"]["away"]["names"]["medium"]


    home_players = {pid: p for pid, p in players.items() if p["teamID"] == home_id}
    away_players = {pid: p for pid, p in players.items() if p["teamID"] == away_id}


    home_starters = get_starters(home_players)
    away_starters = get_starters(away_players)


    # BUILD oddIDs
    home_odds_req = build_team_odds_request(home_starters)
    away_odds_req = build_team_odds_request(away_starters)


    # FETCH all props in 1 request per team
    home_props_data = get_team_props_with_cache(home_odds_req, tag="pacers")
    away_props_data = get_team_props_with_cache(away_odds_req, tag="suns")


    if not home_props_data or not away_props_data:
        print("API returned empty data due to rate limits. Try again in 1 minute.")
        return


    home_odds = home_props_data["data"][0]["odds"]
    away_odds = away_props_data["data"][0]["odds"]


    print("==============================")
    print(f"{away_team_short} STARTERS")
    print("==============================")


    for pid in away_starters:
        name = away_players[pid]["name"]
        props = {
            "points": parse_props(pid, "points", away_odds),
            "rebounds": parse_props(pid, "rebounds", away_odds),
            "assists": parse_props(pid, "assists", away_odds),
        }
        print_player_props(name, props)


    print("\n==============================")
    print(f"{home_team_short} STARTERS")
    print("==============================")


    for pid in home_starters:
        name = home_players[pid]["name"]
        props = {
            "points": parse_props(pid, "points", home_odds),
            "rebounds": parse_props(pid, "rebounds", home_odds),
            "assists": parse_props(pid, "assists", home_odds),
        }
        print_player_props(name, props)




if __name__ == "__main__":
    main()
