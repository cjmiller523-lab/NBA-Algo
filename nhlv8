import os
import json
import time
import requests
from datetime import datetime
from collections import defaultdict

# ==========================================================
# CONFIG
# ==========================================================

NUM_GAMES = 10
MIN_AVG_TOI = 10.0
SEASON_ID = "20252026"
GAME_TYPE = 2

SOG_THRESHOLDS = [2, 3, 4, 5, 6]

CACHE_DIR = "nhl_cache/player_logs"
TWITTER_DIR = "twitter_posts"

os.makedirs(CACHE_DIR, exist_ok=True)
os.makedirs(TWITTER_DIR, exist_ok=True)

# ==========================================================
# HELPERS
# ==========================================================

def debug(msg):
    print(f"[DEBUG] {msg}")

def get_tier(hits):
    if hits == 10:
        return "LOCK"
    elif hits == 9:
        return "T1"
    elif hits == 8:
        return "T2"
    return None

# ==========================================================
# NHL API FETCHERS
# ==========================================================

def get_todays_games():
    today = datetime.now().strftime("%Y-%m-%d")
    url = f"https://api-web.nhle.com/v1/schedule/{today}"

    r = requests.get(url, timeout=10)
    r.raise_for_status()
    data = r.json()

    games = []
    for day in data.get("gameWeek", []):
        if day.get("date") != today:
            continue

        for g in day.get("games", []):
            games.append({
                "home": g["homeTeam"]["abbrev"],
                "away": g["awayTeam"]["abbrev"],
            })

    debug(f"Found {len(games)} games TODAY")
    return games

def normalize_name(val):
    if isinstance(val, dict):
        return val.get("default", "")
    return val or ""

def get_team_roster(team_abbrev):
    url = f"https://api-web.nhle.com/v1/roster/{team_abbrev}/current"

    r = requests.get(url, timeout=10)
    r.raise_for_status()
    data = r.json()

    players = []

    for p in data.get("forwards", []) + data.get("defensemen", []):
        name = (
            normalize_name(p.get("fullName")) or
            normalize_name(p.get("defaultName")) or
            f"{normalize_name(p.get('firstName'))} {normalize_name(p.get('lastName'))}".strip()
        )

        players.append({
            "id": p["id"],
            "name": name,
            "team": team_abbrev,
            "pos": "D" if p in data.get("defensemen", []) else "F"
        })

    return players

def get_player_log(player_id):
    cache_path = f"{CACHE_DIR}/{player_id}.json"

    if os.path.exists(cache_path):
        with open(cache_path) as f:
            return json.load(f)

    url = f"https://api-web.nhle.com/v1/player/{player_id}/game-log/{SEASON_ID}/{GAME_TYPE}"
    r = requests.get(url, timeout=10)
    r.raise_for_status()
    data = r.json()

    with open(cache_path, "w") as f:
        json.dump(data, f)

    time.sleep(0.15)
    return data

# ==========================================================
# OPPONENT SHOT ALLOWED (TEAM LEVEL)
# ==========================================================

TEAM_SHOTS_ALLOWED_CACHE = {}

TEAM_SHOTS_ALLOWED_CACHE = {}

def get_team_shots_allowed(team_abbrev):
    """
    Returns shots-against per game for a team.
    Cached after first load.
    """

    if TEAM_SHOTS_ALLOWED_CACHE:
        return TEAM_SHOTS_ALLOWED_CACHE.get(team_abbrev, 30)

    debug("Fetching league team shots-against data")

    url = "https://api.nhle.com/stats/rest/en/team/summary"
    r = requests.get(url, timeout=10)
    r.raise_for_status()
    data = r.json()

    for row in data.get("data", []):
        abbr = row.get("teamAbbrev")
        sa = row.get("shotsAgainstPerGame", 30)

        TEAM_SHOTS_ALLOWED_CACHE[abbr] = sa

    return TEAM_SHOTS_ALLOWED_CACHE.get(team_abbrev, 30)


# ==========================================================
# STATS
# ==========================================================

def parse_toi(toi):
    if not toi or ":" not in toi:
        return 0
    m, s = toi.split(":")
    return int(m) + int(s) / 60

def last_n_games(log):
    games = sorted(log.get("gameLog", []), key=lambda x: x["gameDate"], reverse=True)
    return games[:NUM_GAMES]

def avg_toi_last_n(log):
    games = last_n_games(log)
    if len(games) < NUM_GAMES:
        return 0

    tois = [
        parse_toi(g.get("toi") or g.get("timeOnIce"))
        for g in games
    ]
    return sum(tois) / len(tois)

def last_n_shots(log):
    return [g.get("shots", 0) for g in last_n_games(log)]

def hit_rate(values, threshold):
    return sum(v >= threshold for v in values), len(values)

# ==========================================================
# PLAYER POOL
# ==========================================================

def get_todays_players():
    seen = set()
    players = []

    for g in get_todays_games():
        matchup = f"{g['away']} @ {g['home']}"

        for team in [g["home"], g["away"]]:
            roster = get_team_roster(team)

            for p in roster:
                if p["id"] in seen:
                    continue

                seen.add(p["id"])
                p["matchup"] = matchup
                players.append(p)

    debug(f"Total players today: {len(players)}")
    return players

# ==========================================================
# OUTPUT / RANKING
# ==========================================================

def normalize_confidence(values):
    min_v = min(values)
    max_v = max(values)
    if max_v == min_v:
        return [75 for _ in values]

    return [
        round(100 * (v - min_v) / (max_v - min_v), 1)
        for v in values
    ]

def best_bets_per_game(results):
    games = defaultdict(list)

    for r in results:
        games[r["matchup"]].append(r)

    final = {}

    for matchup, props in games.items():
        props.sort(key=lambda x: x["confidence"], reverse=True)

        best = []
        used = set()

        for p in props:
            if p["player"] in used:
                continue

            best.append(p)
            used.add(p["player"])

            if len(best) == 4:
                break

        final[matchup] = best

    return final

def save_best_bets(best_bets):
    path = f"{TWITTER_DIR}/nhl_best_bets_{datetime.now().strftime('%Y-%m-%d')}.txt"
    lines = ["üî• NHL BEST BETS ‚Äî Shots on Goal", ""]

    for matchup, bets in best_bets.items():
        lines.append(matchup)
        for b in bets:
            icon = "üî•" if b["tier"] == "LOCK" else "‚≠ê"
            lines.append(
                f"{icon} {b['player']} ‚Äî SOG {b['threshold']}+ "
                f"| {b['hits']}/{b['total']} "
                f"(conf {b['confidence']})"
            )
        lines.append("")

    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    debug(f"Best bets Twitter text saved to {path}")

# ==========================================================
# MAIN
# ==========================================================

def main():
    debug("===== NHL SOG DAILY RUN START =====")

    players = get_todays_players()
    results = []

    raw_confidences = []

    for p in players:
        log = get_player_log(p["id"])

        if len(log.get("gameLog", [])) < NUM_GAMES:
            continue

        avg_toi = avg_toi_last_n(log)
        if avg_toi < MIN_AVG_TOI:
            continue

        shots = last_n_shots(log)
        avg_shots = sum(shots) / len(shots)

        # opponent factor
        opp = p["matchup"].replace(p["team"], "").replace("@", "").strip()
        opp_shots_allowed = get_team_shots_allowed(opp)

        for t in SOG_THRESHOLDS:
            hits, total = hit_rate(shots, t)
            tier = get_tier(hits)
            if not tier:
                continue

            # RAW CONFIDENCE
            raw_conf = (
                hits * 10 +
                t * 6 +
                avg_shots * 2 +
                avg_toi +
                (opp_shots_allowed - 30) * (1.5 if p["pos"] == "F" else 0.75)
            )

            raw_confidences.append(raw_conf)

            results.append({
                "player": p["name"],
                "matchup": p["matchup"],
                "threshold": t,
                "hits": hits,
                "total": total,
                "tier": tier,
                "raw_confidence": raw_conf
            })

    # Normalize confidence
    normalized = normalize_confidence(raw_confidences)
    for r, n in zip(results, normalized):
        r["confidence"] = n

    best_bets = best_bets_per_game(results)
    save_best_bets(best_bets)

    debug("===== NHL SOG DAILY RUN END =====")

if __name__ == "__main__":
    main()
